# üîí Actividad 6: Autenticaci√≥n y Seguridad ‚Äì Protegiendo la API con JWT 

## üéØ Prop√≥sito 
En esta actividad agregar√°s **autenticaci√≥n y autorizaci√≥n** a tu API de tareas para que solo usuarios autorizados puedan acceder a los endpoints. Esto implica implementar un mecanismo de login que entregue un token de seguridad (usaremos **JWT**, JSON Web Tokens) y exigir ese token en las rutas de la API. El objetivo es que experimentes c√≥mo GitHub Copilot puede asistirte en incorporar medidas de seguridad en tu aplicaci√≥n sin perder fluidez de desarrollo. *Existen varios m√©todos comunes para asegurar APIs* (como **Autenticaci√≥n B√°sica**, **API Keys**, **OAuth 2.0** y **JWT**, entre otros), pero en este laboratorio nos centraremos en JWT por ser una soluci√≥n moderna, **stateless** y ampliamente usada para APIs web. Un **JWT** es un token firmado digitalmente que el servidor genera tras verificar las credenciales de un usuario, y que el cliente debe enviar en cada petici√≥n subsecuente (t√≠picamente en la cabecera **Authorization**) para acceder a rutas protegidas. 

Al finalizar, tendr√°s tu backend protegido con autenticaci√≥n JWT y el frontend ajustado para usarlo, manteniendo una buena experiencia de usuario. ¬°Vamos a agregar seguridad a nuestra aplicaci√≥n! üîê

## üß± Punto de partida 
Antes de comenzar, aseg√∫rate de contar con:  
- **Backend listo** con las rutas CRUD de tareas funcionando (resultado de actividades previas). Si has hecho la Actividad 5, tu backend ya persiste tareas en disco.  
- **Frontend funcional** (Angular o Next.js) capaz de listar, crear y marcar tareas (de la Actividad 3).  
- **GitHub Copilot** y **Copilot Chat** activos en tu editor para que te asistan.  
- El paquete de JWT instalado en el backend. Desde la terminal en el proyecto backend, ejecuta:  
  ```bash
  npm install jsonwebtoken @types/jsonwebtoken
  ``` 
  Esto instala la librer√≠a **jsonwebtoken**, popular para crear y verificar JWT en Node.js.  

Adem√°s, piensa en alguna credencial de prueba para el login. Por simplicidad, usaremos un usuario *hardcoded* (por ejemplo, usuario `"admin"` con contrase√±a `"admin123"`), ya que no tenemos gesti√≥n de usuarios ni base de datos de credenciales en este proyecto de hackathon. 

## üõ†Ô∏è Paso a paso con Copilot 

### 1. Configura un secreto y middleware b√°sico de JWT en el backend  
Abre tu archivo principal del servidor (por ejemplo, `index.ts`). Vamos a configurar un **‚Äúsecreto‚Äù** para firmar los tokens. Escribe un comentario:  
```ts
// Configurar secreto JWT y middleware de verificaci√≥n
```  
üí° **Copilot** deber√≠a sugerir la creaci√≥n de una constante con la clave secreta (por ejemplo, `const JWT_SECRET = "algoMuySecreto";`). En un entorno real, esta clave debe almacenarse en variables de entorno y nunca en el c√≥digo fuente p√∫blico, pero para este ejercicio puedes definirla directamente. Copilot tambi√©n podr√≠a empezar a esbozar una funci√≥n middleware para verificar tokens en las solicitudes. Si no ves sugerencias, p√≠dele ayuda en Copilot Chat:  
> *‚Äú¬øC√≥mo configuro un middleware en Express para validar un JWT?‚Äù*  

Acepta la sugerencia si ves que crea una funci√≥n, quiz√°s llamada `verifyToken` o similar, que use `jsonwebtoken`. En esencia, este **middleware** debe: obtener el token del header `Authorization`, verificarlo con `jwt.verify(token, JWT_SECRET)`, manejar errores si el token es inv√°lido o expir√≥, y llamar a `next()` si todo est√° bien. Aseg√∫rate de que retorne un **401 Unauthorized** si no hay token o es inv√°lido. Copilot podr√≠a sugerir algo as√≠: 

```ts
function verifyToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) {
    return res.sendStatus(401);
  }
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;  // guardar info del usuario si fuera necesario
    next();
  } catch (err) {
    return res.sendStatus(403);
  }
}
``` 

Si la sugerencia no aparece completa, gu√≠ala a√±adiendo detalles en comentarios (por ejemplo: `// usar jwt.verify para validar el token`). Preguntas √∫tiles para Copilot Chat podr√≠an ser:  
> *‚Äú¬øC√≥mo obtengo el token JWT del header Authorization en Express?‚Äù*  

> *‚Äú¬øQu√© respuesta doy si el token no es v√°lido?‚Äù*  

### 2. Crea una ruta de **login** que emita un token JWT  
Ahora implementaremos la ruta para **iniciar sesi√≥n**. Esta ruta recibir√° credenciales (usuario y contrase√±a) y, si son correctas, devolver√° un token JWT firmado. En tu servidor Express, escribe un comentario para que Copilot lo reconozca, por ejemplo:  
```ts
// Ruta POST /login que valida credenciales y devuelve un JWT
```  
‚úã **Detente y observa** si Copilot te sugiere c√≥digo para la ruta. Idealmente, deber√≠a: 1) leer `req.body` para usuario y contrase√±a, 2) comprobar que coinciden con nuestro usuario de prueba (ej. `"admin"/"admin123"`), y 3) si son v√°lidos, generar un token con `jwt.sign`. Si Copilot no completa la l√≥gica, puedes guiarlo paso a paso. Escribe por ejemplo:  
```ts
// Si las credenciales son v√°lidas, generar token JWT con jwt.sign
```  
Copilot podr√≠a entonces sugerir algo utilizando `jwt.sign({ userId: ... }, JWT_SECRET, { expiresIn: '1h' })`[3](https://dev.to/ilyasgaraad/secure-your-rest-api-with-jwt-authentication-beginner-friendly-2e5f). Usa un **payload** sencillo, por ejemplo el ID o nombre de usuario. Para nuestro demo, podr√≠amos hacer:  
```ts
const token = jwt.sign({ username: user }, JWT_SECRET, { expiresIn: '1h' });
```  
Esto crea un token v√°lido por **1 hora**. Establecer expiraci√≥n es importante para limitar el tiempo en que un token robado ser√≠a √∫til. Si las credenciales no coinciden, la ruta debe responder con un error (401 o 403). Copilot puede sugerir un mensaje de error como *"Credenciales inv√°lidas"* en ese caso. 

> üóíÔ∏è *Nota:* Normalmente las contrase√±as no se comparan en texto plano, se almacenar√≠an cifradas y se verificar√≠an con hashing seguro. Pero en este contexto simplificado aceptaremos una comparaci√≥n directa para enfocarnos en JWT. Aun as√≠, es bueno preguntar a Copilot Chat por curiosidad: *‚Äú¬øC√≥mo deber√≠a almacenar y verificar contrase√±as de usuarios de forma segura?‚Äù*.

### 3. Protege las rutas de tareas con el middleware de autenticaci√≥n  
Con la ruta de login lista, vamos a **restringir el acceso** a las dem√°s rutas (las de tareas) usando el middleware `verifyToken` creado en el paso 1. Es probable que tus rutas CRUD de tareas est√©n registradas algo como:  
```ts
app.get('/tasks', ...);
app.post('/tasks', ...);
``` 
y as√≠ sucesivamente. Para asegurarlas, inserta el middleware de dos formas posibles: 

- **Opci√≥n 1:** Usar el middleware en cada ruta, por ejemplo:  
  ```ts
  app.get('/tasks', verifyToken, (req, res) => { ... });
  ``` 
  de manera que antes de ejecutar la l√≥gica de la ruta se valide el token. 

- **Opci√≥n 2:** Usar `app.use` en el router de tareas para aplicar el middleware a todas las subrutas. Por ejemplo, si tienes algo como `app.use('/tasks', tasksRouter)`, puedes aplicar `tasksRouter.use(verifyToken)` o directamente `app.use('/tasks', verifyToken, tasksRouter)`. 

Elige el enfoque seg√∫n c√≥mo est√© estructurado tu c√≥digo. Si todas las rutas est√°n en el mismo archivo, quiz√°s la opci√≥n 1 sea m√°s sencilla a√±adiendo `verifyToken` como segundo argumento en cada ruta. 

Escribe en tu c√≥digo un comentario sobre proteger las rutas, por ejemplo:  
```ts
// Proteger rutas /tasks/* con el middleware de autenticaci√≥n
```  
Copilot puede autom√°ticamente insertar el middleware en cada ruta definida debajo. Revisa que efectivamente ahora **todas las operaciones CRUD de tareas requieren haber enviado un token v√°lido**. Para verificarlo, puedes intentar arrancar el servidor y hacer una petici√≥n a `/tasks` sin token: deber√≠a responder **401 Unauthorized** (o 403 Forbidden si token inv√°lido). Si en lugar de eso tienes acceso libre, repasa si colocaste bien el middleware. Ante dudas, pregunta a Copilot Chat:  
> *‚Äú¬øC√≥mo protejo mis rutas Express usando un middleware de JWT?‚Äù*  

### 4. Actualiza el **frontend**: flujo de Login y almacenamiento del token  
Con el backend seguro, necesitamos modificar el frontend para que pueda **obtener y usar el token JWT**. Esto implica dos tareas principales en la aplicaci√≥n cliente: **iniciar sesi√≥n** (pedir credenciales al usuario y llamar al nuevo endpoint `/login`) y luego **adjuntar el token** en las peticiones a la API. 

#### a) A√±adir interfaz de inicio de sesi√≥n  
En tu aplicaci√≥n frontend (ya sea Angular o Next.js/React), crea un simple formulario de login. Por ejemplo: un campo de texto para ‚Äúusuario‚Äù, otro para ‚Äúcontrase√±a‚Äù y un bot√≥n ‚ÄúIngresar‚Äù. No es necesario gestionar registros de usuarios; solo autenticaremos al usuario de prueba conocido. 

En Angular, podr√≠as generar un componente de login o simplemente agregar el formulario en el componente existente que lista tareas (condicionalmente mostrando uno u otro). En Next.js/React, puedes crear un peque√±o componente o usar el estado local para condicionar la vista. **Usa Copilot para acelerar esto**: Por ejemplo, en Angular abre el HTML relevante y escribe un comentario:  
```html
<!-- Formulario de login con inputs de usuario, password y bot√≥n --> 
``` 
Copilot deber√≠a sugerir un snippet de formulario (por ejemplo usando `[(ngModel)]` para enlazar dos variables en el componente TS, y un `(ngSubmit)` o click en el bot√≥n para llamar a una funci√≥n de login). Acepta la sugerencia y luego ve al archivo TypeScript correspondiente y escribe un comentario como:  
```ts
// M√©todo login() que env√≠a credenciales al backend y maneja el token
``` 
Copilot puede autocompletar la l√≥gica: usar HttpClient (Angular) o fetch (Next.js) para hacer un **POST** a `http://localhost:3000/login` con el usuario y contrase√±a, y recibir el token en la respuesta. Aseg√∫rate de **guardar el token** cuando llegue. Por ejemplo, en Angular podr√≠as almacenarlo en `localStorage`:  
```ts
localStorage.setItem('token', receivedToken);
``` 
En React, podr√≠as usar `localStorage` igualmente o manejarlo en un estado global/contexto. Puedes preguntar a Copilot Chat:  
> *‚Äú¬øC√≥mo guardo un token JWT en el navegador de forma segura?‚Äù*  

Copilot puede mencionar que **localStorage** es sencillo pero susceptible a ataques XSS, mientras que usar **cookies HttpOnly** es m√°s seguro. Para este ejercicio, usaremos localStorage por simplicidad, pero **ten en cuenta las implicaciones de seguridad**. 

Una vez almacenado el token, tu frontend deber√≠a saber que el usuario ‚Äúest√° logueado‚Äù. Puedes, por ejemplo, mantener un estado booleano `isLoggedIn` en el componente (true despu√©s de login exitoso) o simplemente checar la existencia de `localStorage.getItem('token')`. Usa esa condici√≥n para mostrar la lista de tareas solo si hay token; si no, mostrar el formulario de login. De esta manera forzamos al usuario a loguearse antes de acceder a las tareas. 

#### b) Incluir el token en las peticiones desde el frontend  
Ahora viene la parte crucial: el frontend debe enviar el token al backend en cada llamada a la API de tareas. Esto suele hacerse agregando un header **Authorization: Bearer \<token\>** en las solicitudes HTTP. 

- **En Angular**: Si usas un servicio (`HttpClient`) para obtener las tareas, modifica la llamada GET (y las POST/PUT/DELETE) para a√±adir el header. Por ejemplo:  
  ```ts
  const token = localStorage.getItem('token');
  this.http.get('/tasks', {
      headers: new HttpHeaders().set('Authorization', `Bearer ${token}`)
  });
  ``` 
  Puedes guiar a Copilot escribiendo un comentario en el servicio:  
  ```ts
  // Incluir el header Authorization con Bearer token si existe
  ``` 
  Es probable que sugiera el c√≥digo adecuado para adjuntar el token. Otra forma m√°s elegante es implementar un **HttpInterceptor** que agregue autom√°ticamente el header a cada petici√≥n. Esto es opcional; si tienes tiempo en el hackathon, podr√≠as intentar que Copilot cree un interceptor (preguntando: *‚Äú¬øC√≥mo implemento HttpInterceptor para JWT en Angular?‚Äù*), pero no es obligatorio. 

- **En Next.js/React**: Si en la actividad anterior usaste `fetch` para las peticiones, ahora deber√°s incluir el header en cada fetch. Podr√≠as centralizarlo, pero quiz√° lo m√°s directo es modificar las funciones que hac√≠an fetch. Por ejemplo:  
  ```jsx
  const token = localStorage.getItem('token');
  fetch('http://localhost:3000/tasks', {
    headers: { 'Authorization': 'Bearer ' + token }
  })
  ``` 
  Haz algo similar para POST/PUT/DELETE. Una t√©cnica com√∫n en React es guardar el token en un Context o en estado global (usando Redux o similar) para accederlo f√°cilmente, pero para no complicar el laboratorio, leer de `localStorage` cuando se necesite est√° bien. Aseg√∫rate de que este c√≥digo solo se ejecute cuando el token exista (es decir, despu√©s de login). 

Despu√©s de estos cambios, tu aplicaci√≥n cliente enviar√° el JWT en cada solicitud. Gracias a nuestro middleware en el backend, **solo** si el token es v√°lido las operaciones se completar√°n. 

### 5. Prueba la funcionalidad segura end-to-end  
¬°Hora de probar! üéâ Inicia tu backend (por ejemplo, `npm start` o `npx ts-node-dev index.ts`) y tu frontend (Angular: `ng serve`, Next: `npm run dev`). Abre tu aplicaci√≥n en el navegador: 

- Si todo est√° bien, inicialmente deber√≠a aparecer el **formulario de login**. Intenta acceder a la lista de tareas sin loguearte (por ejemplo, si tu app muestra la lista vac√≠a autom√°ticamente, deber√≠a haber fallos en la consola de las peticiones a `/tasks` con **401**). 
- Ingresa las credenciales de prueba (por ejemplo *admin/admin123*) y env√≠alas. Si la autenticaci√≥n fue exitosa, tu frontend recibi√≥ un token JWT y lo guard√≥. Ahora la vista deber√≠a actualizarse para mostrar la interfaz de tareas (lista, formulario de nueva tarea, etc.). 
- Prueba crear, marcar y borrar tareas como antes. Todas esas peticiones ahora van con el token; deber√≠an funcionar como antes si el token es v√°lido. Si modificas el token manualmente o lo borras de `localStorage`, las peticiones volver√°n a fallar con 401/403. 

Tambi√©n puedes verificar el flujo v√≠a herramientas externas: en **Postman** o **curl**, haz primero un POST a `/login` con las credenciales correctas y toma el token que recibes; luego intenta un GET a `/tasks` sin token (debe fallar) y luego con el header `Authorization: Bearer <tuToken>` (debe tener √©xito). 

En caso de problemas:  
- Si el login falla, revisa que el usuario/contrase√±a enviados coincidan con los codificados en el backend. 
- Si el login funciona pero luego todas las peticiones siguen fallando, asegura que el token se est√° adjuntando correctamente en los headers. Observa en la pesta√±a Network del navegador si el request lleva la cabecera Authorization. 
- Si ves errores de CORS al hacer la petici√≥n `/login` desde el frontend, quiz√° necesites habilitar CORS en el backend Express (con el paquete `cors`). Copilot te puede ayudar si preguntas: *‚Äú¬øC√≥mo habilito CORS en Express?‚Äù*. 

## üß™ Validaci√≥n 
Para dar por completada la actividad, verifica los siguientes puntos: 

1. **El endpoint `/login` funciona correctamente**: Cuando le env√≠as las credenciales v√°lidas, responde con un token JWT. Con credenciales inv√°lidas, responde con un c√≥digo de error (401 o 403) apropiado.  
2. **Las rutas de tareas requieren autenticaci√≥n**: Si intentas acceder a cualquier ruta de tareas (GET/POST/PUT/DELETE `/tasks`) **sin** enviar el token, el servidor responde con **401 Unauthorized**. En cambio, al incluir un token v√°lido en el header, la operaci√≥n procede con normalidad.  
3. **El frontend tiene un flujo de login** visible y funcional: No permite acceder a la lista de tareas sin antes haber ingresado las credenciales. Despu√©s de login, la aplicaci√≥n muestra y permite operar las tareas como antes, usando el token en cada petici√≥n.  
4. **Manejo de expiraci√≥n**: Si quieres probar la expiraci√≥n del token, puedes temporariamente reducir `expiresIn` a un valor corto (ej. `"10s"`) en el backend y recompilar. Inicia sesi√≥n y espera 10 segundos; el siguiente intento de acci√≥n deber√≠a fallar con 403, obligando a loguearte de nuevo. En un escenario real, implementar√≠amos un **refresh token** para renovar el acceso sin pedir credenciales tan frecuentemente, pero eso est√° fuera del alcance de este laboratorio.  

Si todas estas condiciones se cumplen, ¬°felicidades! Tu API ahora est√° securizada. Si encuentras alg√∫n error, no dudes en consultar a Copilot Chat con el mensaje de error o una descripci√≥n del problema. Por ejemplo: *‚ÄúEl token no se adjunta correctamente, ¬øqu√© podr√≠a estar mal?‚Äù*. Copilot puede darte pistas √∫tiles. 

## üí° Sugerencias de uso de Copilot Chat 
- *‚Äú¬øC√≥mo implemento autenticaci√≥n JWT en Express de manera segura?‚Äù* ‚Äì Puedes pedir un resumen te√≥rico o ejemplo de c√≥digo; Copilot te recordar√° que debes verificar el token en cada solicitud y no exponer la clave secreta.  
- *‚Äú¬øC√≥mo agrego el header Authorization en las peticiones HTTP desde Angular?‚Äù* ‚Äì √ötil si necesitas ayuda con HttpHeaders o interceptores en Angular.  
- *‚Äú¬øD√≥nde debo guardar el JWT en el frontend?‚Äù* ‚Äì Para discutir sobre **LocalStorage vs Cookies** y las implicaciones de seguridad de cada uno (por ejemplo, LocalStorage es vulnerable a XSS).  
- *‚Äú¬øC√≥mo manejar tokens expirados y renovar el JWT autom√°ticamente?‚Äù* ‚Äì Si te interesa saber sobre **refresh tokens** y estrategias para mantener sesiones activas sin molestar al usuario. Copilot te puede explicar c√≥mo funciona un flujo con `/refresh` usando cookies HttpOnly para el refresh token.  

## ‚úÖ Resultado esperado 
Al completar esta actividad, deber√≠as contar con: 

- üîê **Seguridad implementada** en tu API: solo usuarios autenticados (que tengan un JWT v√°lido) pueden acceder a las rutas de tareas.  
- üîë **Endpoint de login** funcionando, que entrega un JWT al validar usuario y contrase√±a.  
- üõ°Ô∏è **Middleware de protecci√≥n** en el backend que verifica el token en cada petici√≥n protegida.  
- ü§ù **Frontend actualizado** con una pantalla de login y env√≠o del token en las peticiones subsecuentes.  
- üìñ **Experiencia** en el uso de Copilot para implementar caracter√≠sticas de seguridad. Vislumbraste c√≥mo la IA puede acelerar tareas complejas como la autenticaci√≥n, pero tambi√©n aprendiste la importancia de entender y verificar cuidadosamente esas sugerencias en temas sensibles.  

## üöÄ Reflexi√≥n final 
Integrar autenticaci√≥n y autorizaci√≥n es un paso crucial para llevar tu aplicaci√≥n a un entorno real. En esta actividad, **aprendiste a combinar las sugerencias de Copilot con buenas pr√°cticas de seguridad**, manteniendo el control sobre el c√≥digo. Viste c√≥mo Copilot puede generar r√°pidamente el esqueleto de un sistema de login JWT y ayudarte a propagar el uso del token en el cliente, pero tambi√©n comprobaste que **como desarrollador debes revisar y ajustar** esas sugerencias para garantizar que no haya brechas de seguridad. 

Algunas lecciones clave: utiliza **tokens de corta duraci√≥n** para minimizar riesgos, **almacena los tokens de forma segura** (idealmente en cookies HttpOnly para evitar accesos v√≠a JavaScript malicioso), y nunca expongas tu **secreto JWT** en el cliente ni en repos p√∫blicos. Ten en cuenta que la autenticaci√≥n robusta suele requerir m√°s consideraciones (manejo de **refresh tokens** para una mejor UX, revocaci√≥n de tokens, cifrado de datos sensibles, etc.), pero ahora tienes una base s√≥lida sobre c√≥mo proteger una API. 

Con la API de tareas autenticada y persistente, y un frontend din√°mico, ¬°tu proyecto de hackathon ha incorporado todos los elementos esenciales de una aplicaci√≥n web segura y moderna! Mant√©n estos aprendizajes presentes en futuros desarrollos. **¬°Excelente trabajo asegurando tu aplicaci√≥n!** üîíüöÄ 

